<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>choke</title>
    <!-- Primary favicon (photo). Add a cache-busting query param to help refresh cached icons -->
    <link rel="icon" href="data/heimlich.png?v=2" type="image/png" sizes="any">
    <link rel="shortcut icon" href="data/heimlich.png?v=2" type="image/png">
    <!-- SVG fallback favicon (small, lightweight) shown if the PNG is not picked up immediately -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='18' ry='18' fill='%23000'/%3E%3Ctext x='50' y='57' font-size='42' font-family='Inter, Arial, sans-serif' fill='%23fff' text-anchor='middle'%3ECH%3C/text%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; }
        body { font-family: 'Inter', sans-serif; overflow: hidden; }
        svg { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; }
        #chart.dimmed {
            opacity: 0.5;
        }
        #corner-image {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            padding: 0;
        }
        #corner-img {
            max-width: 50vw;
            max-height: 70vh;
            border-radius: 0;
            display: block;
        }
        #corner-info {
            display: none;
            position: fixed;
            top: 2vw;
            left: 2vw;
            z-index: 2000;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            padding: 0;
            min-width: 20vw;
        }
        #corner-info div#corner-title {
            font-family: 'Inter', sans-serif;
            font-size: clamp(24px, 3vw, 48px);
            font-weight: 700;
            margin-bottom: clamp(12px, 1.5vw, 24px);
            line-height: 1.2;
        }
        #corner-info div {
            font-family: 'Inter', sans-serif;
            font-size: clamp(14px, 1.5vw, 20px);
            margin-bottom: clamp(4px, 0.4vw, 8px);
            line-height: 1.4;
        }
        #corner-info b {
            color: #000;
        }
        #corner-info span {
            color: #666;
        }
        #welcome-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3000;
            background: rgba(255, 255, 255, 0.95);
            padding: clamp(16px, 3vw, 28px);
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 80vw;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease-out;
        }
        #welcome-message.show {
            opacity: 1;
            pointer-events: auto;
        }
        #welcome-message p {
            font-family: 'Inter', sans-serif;
            font-size: clamp(13px, 1.2vw, 16px);
            line-height: 1.5;
            margin-bottom: 0;
        }
        #welcome-message a {
            color: #007bff;
            text-decoration: underline;
        }
        #welcome-message a:hover {
            color: #0056b3;
        }
        #welcome-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #welcome-backdrop.show {
            opacity: 1;
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <div id="welcome-backdrop"></div>
    <div id="chart"></div>
    <div id="corner-image">
        <img id="corner-img" src="" alt="Restaurant">
    </div>
    <div id="corner-info">
        <div id="corner-title"></div>
        <div><b>Borough:</b> <span id="corner-borough"></span></div>
        <div><b>Neighborhood:</b> <span id="corner-neighborhood"></span></div>
        <div><b>Cuisine:</b> <span id="corner-cuisine"></span></div>
        <div><b>Style:</b> <span id="corner-style"></span></div>
        <div><b>Position:</b> <span id="corner-position"></span></div>
    </div>
    <div id="welcome-message">
        <p>Ever since the Department of Health set the <a href="https://codelibrary.amlegal.com/codes/newyorkcity/latest/NYCadmin/0-0-0-27660?utm_source=chatgpt.com">requirement</a> for choking-victim posters in 1978, New York has treated the rule loosely. Dr. Henry Heimlich's push turned his maneuver into a required public graphic, and the city has spent decades quietly rewriting it through decay, bootlegs, and improvisation. This project uses those posters as a case study to see how New Yorkers handle public space, read official design, and bend the rules whenever they can.</p>
    </div>

    <script>
        // Constants
        let width = window.innerWidth || 928;
        let height = window.innerHeight || 500;
        let radius = Math.min(width, height) / 20; // Responsive radius, slightly bigger
        let step = radius * 3.2;
        const theta = Math.PI * (3 - Math.sqrt(5));

        // Show welcome message
        const welcome = document.getElementById('welcome-message');
        const backdrop = document.getElementById('welcome-backdrop');
        welcome.classList.add('show');
        backdrop.classList.add('show');

        // Dismiss on any click
        const dismissWelcome = () => {
            welcome.classList.remove('show');
            backdrop.classList.remove('show');
            document.removeEventListener('click', dismissWelcome);
        };
        document.addEventListener('click', dismissWelcome);

        // Load data and initialize visualization: read CSV (primary) and use metadata.json as a filename lookup
        Promise.all([
            d3.csv('data/choke-me.csv'),
            fetch('data/metadata.json').then(r => r.json())
        ]).then(([csvRows, metadata]) => {
            // Build quick lookup of available metadata keys by stem and by full filename
            const availableKeys = new Set(Object.keys(metadata));
            const stemToKey = {};
            Object.keys(metadata).forEach(k => {
                const stem = k.replace(/\.[^/.]+$/, '');
                stemToKey[stem] = k;
            });

            // Resolve CSV rows to restaurant objects (use heimlich.png as placeholder when missing)
            const restaurants = csvRows.map(row => {
                const imgField = (row.image_filename || '').toString().trim();
                let filename = null;
                if (!imgField) {
                    filename = 'heimlich.png';
                } else if (availableKeys.has(imgField)) {
                    filename = imgField;
                } else if (stemToKey[imgField]) {
                    filename = stemToKey[imgField];
                } else {
                    // try common extensions
                    const exts = ['.png', '.PNG', '.jpg', '.jpeg'];
                    for (const ex of exts) {
                        if (availableKeys.has(imgField + ex)) {
                            filename = imgField + ex;
                            break;
                        }
                    }
                    if (!filename) filename = 'heimlich.png';
                }

                return {
                    image_filename: filename,
                    restaurant_name: row.restaurant_name || '',
                    borough: row.borough || '',
                    neighborhood: row.neighborhood || '',
                    cuisine: row.cuisine || '',
                    style: row.style || '',
                    position: row.position || ''
                };
            });

            const data = layoutSpiral(restaurants, width, height, radius, step);
            const svg = createSVG();
            const circles = createCircles(svg, data);

            animateBouncing(circles, data);
            setupEventHandlers(svg, circles, data);

            document.getElementById("chart").appendChild(svg.node());

            // Handle window resize for responsive scaling
            window.addEventListener('resize', () => {
                width = window.innerWidth || 928;
                height = window.innerHeight || 500;
                radius = Math.min(width, height) / 20;
                step = radius * 3.2;

                // Preserve visited state
                const visitedMap = new Map(data.map(d => [d.restaurant.restaurant_name, d.visited]));

                // Recalculate layout
                const newData = layoutSpiral(restaurants, width, height, radius, step);

                // Restore visited
                newData.forEach(d => {
                    d.visited = visitedMap.get(d.restaurant.restaurant_name) || false;
                });

                // Update data array
                data.length = 0;
                data.push(...newData);

                // Separate any overlapping circles after resize
                for (let i = 0; i < data.length; i++) {
                    for (let j = i + 1; j < data.length; j++) {
                        const d1 = data[i], d2 = data[j];
                        const dx = d1.x - d2.x, dy = d1.y - d2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 2 * radius) {
                            const n = { x: dx / dist, y: dy / dist };
                            const overlap = 2 * radius - dist;
                            d1.x += n.x * overlap / 2;
                            d1.y += n.y * overlap / 2;
                            d2.x -= n.x * overlap / 2;
                            d2.y -= n.y * overlap / 2;
                        }
                    }
                }

                // Update circles
                circles.data(data)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', radius);

                    // Update patterns
                    svg.selectAll('pattern').each(function(d, i) {
                        d3.select(this)
                            .select('image')
                            .attr('width', radius * 2)
                            .attr('height', radius * 2);
                    });

                    // Update viewBox
                    svg.attr('viewBox', [0, 0, width, height]);
                });
            });

        function layoutSpiral(restaurants, w, h, r, s) {
            let spiralCenterX = w / 2;
            let spiralCenterY = h / 2;

            const tempData = restaurants.map((restaurant, i) => {
                const rad = s * Math.sqrt(i + 0.5);
                const a = theta * i;
                return [spiralCenterX + rad * Math.cos(a), spiralCenterY + rad * Math.sin(a)];
            });

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            tempData.forEach(([x, y]) => {
                minX = Math.min(minX, x - r);
                maxX = Math.max(maxX, x + r);
                minY = Math.min(minY, y - r);
                maxY = Math.max(maxY, y + r);
            });

            const margin = 20;
            const offsetX = (w - (maxX - minX)) / 2 - minX + margin;
            const offsetY = (h - (maxY - minY)) / 2 - minY + margin;

            const zoomFactor = 0.85;
            return restaurants.map((restaurant, i) => {
                const rad = s * Math.sqrt(i + 0.5) * zoomFactor;
                const a = theta * i;
                const x = spiralCenterX + rad * Math.cos(a) + offsetX;
                const y = spiralCenterY + rad * Math.sin(a) + offsetY;
                const vx = (Math.random() - 0.5) * 2.2;
                const vy = (Math.random() - 0.5) * 2.2;
                return { x, y, vx, vy, restaurant, visited: false };
            });
        }

        function createSVG() {
            const svg = d3.create("svg")
                .attr("viewBox", [0, 0, width, height])
                .style("cursor", "pointer");

            svg.append("g");
            const defs = svg.append("defs");

            defs.append("filter")
                .attr("id", "grayscale")
                .append("feColorMatrix")
                .attr("type", "saturate")
                .attr("values", "0");

            return svg;
        }

        function createCircles(svg, data) {
            const defs = svg.select("defs");

            data.forEach((d, i) => {
                const pattern = defs.append("pattern")
                    .attr("id", `pattern-${i}`)
                    .attr("patternUnits", "objectBoundingBox")
                    .attr("width", 1)
                    .attr("height", 1);

                pattern.append("image")
                    .attr("href", `data/${d.restaurant.image_filename}`)
                    .attr("width", radius * 2)
                    .attr("height", radius * 2)
                    .attr("preserveAspectRatio", "xMidYMid slice");
            });

            return svg.select("g").selectAll("circle")
                .data(data)
                .join("circle")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", radius)
                .attr("fill", (d, i) => `url(#pattern-${i})`)
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .attr("filter", d => d.visited ? "url(#grayscale)" : null)
                .style("cursor", "pointer");
        }

        function animateBouncing(circles, data) {
            function update() {
                data.forEach(d => {
                    d.x += d.vx;
                    d.y += d.vy;

                    if (d.x - radius < 0) { d.x = radius; d.vx *= -1; }
                    if (d.x + radius > width) { d.x = width - radius; d.vx *= -1; }
                    if (d.y - radius < 0) { d.y = radius; d.vy *= -1; }
                    if (d.y + radius > height) { d.y = height - radius; d.vy *= -1; }
                });

                for (let i = 0; i < data.length; i++) {
                    for (let j = i + 1; j < data.length; j++) {
                        const d1 = data[i], d2 = data[j];
                        const dx = d1.x - d2.x, dy = d1.y - d2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 2 * radius) {
                            const n = { x: dx / dist, y: dy / dist };
                            const dot = (d1.vx - d2.vx) * n.x + (d1.vy - d2.vy) * n.y;
                            d1.vx -= dot * n.x;
                            d1.vy -= dot * n.y;
                            d2.vx += dot * n.x;
                            d2.vy += dot * n.y;

                            const overlap = 2 * radius - dist;
                            d1.x += n.x * overlap / 2;
                            d1.y += n.y * overlap / 2;
                            d2.x -= n.x * overlap / 2;
                            d2.y -= n.y * overlap / 2;
                        }
                    }
                }

                circles.attr("cx", d => d.x).attr("cy", d => d.y);
                requestAnimationFrame(update);
            }
            update();
        }

        function setupEventHandlers(svg, circles, data) {
            circles.on("click", (event, d) => {
                event.stopPropagation();
                if (d3.select("#corner-image").style("display") === "block") {
                    closeCard();
                } else {
                    d.visited = true;
                    circles.attr("filter", d => d.visited ? "url(#grayscale)" : null);
                    showCard(d.restaurant);
                }
            });

            svg.on("click", closeCard);
        }

        function showCard(restaurant) {
            d3.select("#corner-img").attr("src", `data/${restaurant.image_filename}`);
            d3.select("#corner-image").style("display", "block");

            d3.select("#corner-title").text(restaurant.restaurant_name);
            d3.select("#corner-borough").text(restaurant.borough || "N/A");
            d3.select("#corner-neighborhood").text(restaurant.neighborhood || "N/A");
            d3.select("#corner-cuisine").text(restaurant.cuisine);
            d3.select("#corner-style").text(restaurant.style);
            d3.select("#corner-position").text(restaurant.position);
            d3.select("#corner-info").style("display", "block");

            d3.select("#chart").classed("dimmed", true);
        }

        function closeCard() {
            d3.select("#corner-image").style("display", "none");
            d3.select("#corner-info").style("display", "none");
            d3.select("#chart").classed("dimmed", false);
        }
    </script>
</body>
</html>
