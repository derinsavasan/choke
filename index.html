<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>choke</title>
    <!-- Primary favicon (photo). Add a cache-busting query param to help refresh cached icons -->
    <link rel="icon" href="data/heimlich.png?v=2" type="image/png" sizes="any">
    <link rel="shortcut icon" href="data/heimlich.png?v=2" type="image/png">
    <!-- SVG fallback favicon (small, lightweight) shown if the PNG is not picked up immediately -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='18' ry='18' fill='%23000'/%3E%3Ctext x='50' y='57' font-size='42' font-family='Cabin, sans-serif' fill='%23fff' text-anchor='middle'%3ECH%3C/text%3E%3C/svg%3E">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cabin:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Boldonse&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>
    <style>
        * { margin: 0; padding: 0; }
        body { font-family: 'Cabin', sans-serif; overflow: hidden; }
        #chart, #map {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        #map {
            display: none;
            z-index: 1;
            background: #f6f6f6;
        }
        #map svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        .map-boroughs path {
            stroke-width: 2;
            stroke-linejoin: round;
        }
        .map-markers g.map-marker {
            filter: drop-shadow(0 6px 18px rgba(0, 0, 0, 0.18));
        }
        .map-markers g.map-marker.is-cluster circle {
            fill: #111;
            stroke: #fff;
            stroke-width: 1.6;
        }
        .map-markers g.map-marker.is-cluster text {
            fill: #fff;
        }
        .map-markers g.map-marker.is-point circle {
            fill: #0f0f10;
            stroke: #fff;
            stroke-width: 1;
        }
        #map-tooltip {
            position: fixed;
            display: none;
            pointer-events: none;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 12px 14px;
            z-index: 2600;
            min-width: 170px;
        }
        #map-tooltip .tooltip-title {
            font-size: 17px;
            font-weight: 700;
            color: #111;
            text-align: center;
            margin-bottom: 4px;
        }
        #map-tooltip .tooltip-details {
            font-size: 14px;
            color: #555;
            text-align: center;
            line-height: 1.3;
        }
        #map-info {
            position: fixed;
            top: 2vw;
            left: 2vw;
            max-width: clamp(220px, 26vw, 320px);
            z-index: 2400;
            color: #0f0f10;
            line-height: 1.5;
            font-size: clamp(13px, 1.3vw, 18px);
            font-weight: 400;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.6s ease;
        }
        #map-info.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #map-info img {
            width: 92%;
            height: auto;
            display: block;
            margin-top: 10px;
            box-shadow: 0 12px 32px rgba(0,0,0,0.16);
            margin-left: auto;
            margin-right: auto;
        }
        #map-info .map-info-caption {
            margin-top: 6px;
            font-size: 12px;
            color: #444;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            text-align: right;
            width: 92%;
            margin-left: auto;
            margin-right: auto;
        }
        #legend-hotspot {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 0;
            height: 0;
            z-index: 2600;
            pointer-events: none;
        }
        #legend-button {
            position: absolute;
            bottom: 2vw;
            right: 2vw;
            width: 54px;
            height: 54px;
            border-radius: 50%;
            background: #0f0f10;
            color: #fff;
            font-weight: 700;
            font-size: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 26px rgba(0,0,0,0.24);
            opacity: 0;
            transform: translateY(8px);
            transition: opacity 0.25s ease, transform 0.25s ease, box-shadow 0.2s ease;
            cursor: pointer;
            pointer-events: auto;
        }
        #legend-button.show {
            opacity: 1;
            transform: translateY(0);
        }
        #legend-button:focus-visible {
            outline: 2px solid #555;
            outline-offset: 3px;
        }
        #legend-panel {
            position: absolute;
            bottom: calc(2vw + 64px);
            right: 2vw;
            min-width: 300px;
            max-width: min(420px, 44vw);
            padding: 18px 20px;
            background: rgba(255,255,255,0.96);
            border-radius: 14px;
            box-shadow: 0 12px 32px rgba(0,0,0,0.18);
            opacity: 0;
            transform: translateY(8px);
            transition: opacity 0.25s ease, transform 0.25s ease;
            pointer-events: none;
        }
        #legend-panel.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        #legend-panel p {
            font-size: 15px;
            line-height: 1.5;
            color: #0f0f10;
            margin-bottom: 8px;
        }
        #legend-panel ul {
            list-style: none;
        }
        #legend-panel li {
            font-size: 15px;
            line-height: 1.4;
            color: #333;
            margin-bottom: 6px;
        }
        #legend-panel b {
            font-weight: 700;
        }
        #map-compare {
            position: fixed;
            top: 2vw;
            left: 2vw;
            display: flex;
            gap: 14px;
            z-index: 2450;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #map-compare.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .map-compare-card {
            display: flex;
            flex-direction: column;
            width: clamp(140px, 15vw, 200px);
            align-items: flex-end;
        }
        .map-compare-card img {
            width: 100%;
            height: auto;
            display: block;
            object-fit: cover;
            box-shadow: 0 10px 28px rgba(0,0,0,0.16);
        }
        .map-compare-card .caption {
            margin-top: 6px;
            font-size: 12px;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            color: #444;
            text-align: right;
            width: 100%;
        }
        svg { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; }
        #chart.dimmed {
            opacity: 0.5;
        }
        #view-toggle {
            position: fixed;
            top: 2vw;
            right: 2vw;
            z-index: 2500;
            width: 220px;
            height: 44px;
            background: #0f0f10;
            border-radius: 999px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            padding: 0 4px;
        }
        #view-toggle button {
            flex: 1;
            border: none;
            background: transparent;
            padding: 10px 0;
            border-radius: 999px;
            font-family: 'Cabin', sans-serif;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            color: rgba(255,255,255,0.7);
            transition: color 0.2s ease;
            position: relative;
            z-index: 2;
        }
        #view-toggle button:focus-visible {
            outline: none;
        }
        #view-toggle .toggle-pill {
            position: absolute;
            top: 4px;
            left: 4px;
            width: calc(50% - 8px);
            height: calc(100% - 8px);
            background: #fff;
            border-radius: 999px;
            transition: left 0.3s ease;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
            z-index: 1;
        }
        #view-toggle[data-active="map"] .toggle-pill {
            left: calc(50% + 4px);
        }
        #view-toggle button.active {
            color: #111;
        }
        #corner-image {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            padding: 0;
        }
        #corner-img {
            max-width: 50vw;
            max-height: 70vh;
            border-radius: 0;
            display: block;
        }
        #corner-info {
            display: none;
            position: fixed;
            top: 2vw;
            left: 2vw;
            z-index: 2000;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            padding: 0;
            min-width: 20vw;
        }
        #corner-info div#corner-title {
            font-family: 'Boldonse', 'Cabin', sans-serif;
            font-size: clamp(24px, 3vw, 48px);
            font-weight: 700;
            margin-bottom: clamp(12px, 1.5vw, 24px);
            line-height: 1.2;
        }
        #corner-info div {
            font-family: 'Cabin', sans-serif;
            font-size: clamp(14px, 1.5vw, 20px);
            margin-bottom: clamp(3px, 0.3vw, 6px);
            line-height: 1.3;
        }
        #corner-info b {
            color: #000;
        }
        #corner-info span {
            color: #000;
        }
        #welcome-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3000;
            background: rgba(255, 255, 255, 0.95);
            padding: clamp(16px, 3vw, 28px);
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 80vw;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease-out;
        }
        #welcome-message.show {
            opacity: 1;
            pointer-events: auto;
        }
        #welcome-message p {
            font-family: 'Cabin', sans-serif;
            font-size: clamp(14px, 1.3vw, 18px);
            line-height: 1.5;
            margin-bottom: 0;
        }
        #welcome-message a {
            color: #007bff;
            text-decoration: underline;
        }
        #welcome-message a:hover {
            color: #0056b3;
        }
        #welcome-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #welcome-backdrop.show {
            opacity: 1;
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <div id="welcome-backdrop"></div>
    <div id="view-toggle" role="tablist" aria-label="Visualization view" data-active="bubbles">
        <div class="toggle-pill"></div>
        <button type="button" class="active" data-view="bubbles" aria-pressed="true">Posters</button>
        <button type="button" data-view="map" aria-pressed="false">Map</button>
    </div>
    <div id="chart"></div>
    <div id="map" aria-hidden="true"></div>
    <div id="map-info" aria-hidden="true">
        <p>NYC Health needed a fast, jargon-free way to teach the maneuver, so they used a bold, cartoon-style diagram that can be absorbed in seconds. Zoom in to explore the pins and compare each restaurant's poster to NYC's sample version.</p>
        <img src="data/choking-poster-sample.png" alt="Sample NYC choking poster">
        <div class="map-info-caption">Sample NYC choking poster</div>
    </div>
    <div id="map-compare" aria-hidden="true">
        <div class="map-compare-card">
            <img id="map-compare-sample" src="data/choking-poster-sample.png" alt="Sample NYC choking poster">
            <div class="caption">Sample NYC choking poster</div>
        </div>
        <div class="map-compare-card">
            <img id="map-compare-restaurant" src="" alt="Restaurant poster">
            <div class="caption" id="map-compare-restaurant-caption"></div>
        </div>
    </div>
    <div id="map-tooltip">
        <div class="tooltip-title"></div>
        <div class="tooltip-details"></div>
    </div>
    <div id="legend-hotspot" aria-hidden="true">
        <div id="legend-button" aria-label="Show legend" role="button" tabindex="0">?</div>
        <div id="legend-panel" role="dialog" aria-modal="false" aria-label="Position legend">
            <ul>
                <li><b>Eye Level:</b> directly in front of guests</li>
                <li><b>Hidden Spot:</b> tucked out of main view</li>
                <li><b>Hallway Niche:</b> narrow connector spaces between rooms</li>
                <li><b>Bathroom Shrine:</b> inside bathroom walls/stalls</li>
                <li><b>Counter Zone:</b> at service and ordering counters</li>
                <li><b>Above the Sink:</b> mounted over sink areas</li>
                <li><b>Behind the Drinks:</b> behind fridges or bar backs</li>
                <li><b>Near Exit Sign:</b> next to doors and exit signage</li>
            </ul>
        </div>
    </div>
    <div id="corner-image">
        <img id="corner-img" src="" alt="Restaurant">
    </div>
    <div id="corner-info">
        <div id="corner-title"></div>
        <div><b>Borough:</b> <span id="corner-borough"></span></div>
        <div><b>Neighborhood:</b> <span id="corner-neighborhood"></span></div>
        <div><b>Cuisine:</b> <span id="corner-cuisine"></span></div>
        <div><b>Style:</b> <span id="corner-style"></span></div>
        <div><b>Position:</b> <span id="corner-position"></span></div>
    </div>
    <div id="welcome-message">
        <p>Ever since the Department of Health set the <a href="https://codelibrary.amlegal.com/codes/newyorkcity/latest/NYCadmin/0-0-0-27660?utm_source=chatgpt.com" target="_blank" rel="noopener noreferrer">requirement</a> for choking-victim posters in 1978, New York has treated the rule loosely. Dr. Henry Heimlich's push turned his maneuver into a required public graphic, and the city has spent decades quietly rewriting it through decay, bootlegs, and improvisation. This project uses those posters as a case study to see how New Yorkers handle public space, read official design, and bend the rules whenever they can.</p>
    </div>

    <script>
        // Constants
        let width = window.innerWidth || 928;
        let height = window.innerHeight || 500;
        let radius = Math.min(width, height) / 20; // Responsive radius, slightly bigger
        let step = radius * 3.2;
        const theta = Math.PI * (3 - Math.sqrt(5));
        let bounceControls = null;
        const mapState = { render: null };
        const mapTooltipEl = document.getElementById('map-tooltip');
        const mapInfoEl = document.getElementById('map-info');
        const mapCompareEl = document.getElementById('map-compare');
        const mapCompareRestaurantImg = document.getElementById('map-compare-restaurant');
        const mapCompareRestaurantCaption = document.getElementById('map-compare-restaurant-caption');
        const legendHotspot = document.getElementById('legend-hotspot');
        const legendButton = document.getElementById('legend-button');
        const legendPanel = document.getElementById('legend-panel');
        let legendOpen = false;
        const LEGEND_HOVER_MARGIN = 220;
        let currentView = 'bubbles';
        const colorCache = new Map();
        let cardAccentToken = 0;
        // Toggle to exclude rows that do not have a resolvable image; set to false to fall back to the placeholder instead
        const hideEntriesWithoutImages = true;

        // Show welcome message
        const welcome = document.getElementById('welcome-message');
        const backdrop = document.getElementById('welcome-backdrop');
        welcome.classList.add('show');
        backdrop.classList.add('show');

        // Dismiss on any click
        const dismissWelcome = () => {
            welcome.classList.remove('show');
            backdrop.classList.remove('show');
            document.removeEventListener('click', dismissWelcome);
        };
        document.addEventListener('click', dismissWelcome);

        function hideGlobalMapTooltip() {
            if (mapTooltipEl) {
                mapTooltipEl.style.display = 'none';
            }
        }

        function hideMapCompare() {
            if (mapCompareEl) {
                mapCompareEl.classList.remove('visible');
                mapCompareEl.setAttribute('aria-hidden', 'true');
            }
        }

        function closeLegend() {
            if (!legendPanel) return;
            legendPanel.classList.remove('visible');
            legendPanel.setAttribute('aria-hidden', 'true');
            legendOpen = false;
        }

        // Load data and initialize visualization: read CSV (primary), metadata lookup, and borough geojson
        Promise.all([
            d3.csv('data/choke-me.csv'),
            fetch('data/metadata.json').then(r => r.json()),
            fetch('data/nyc.geojson').then(r => r.json())
        ]).then(([csvRows, metadata, boroughsGeo]) => {
            // Build quick lookup of available metadata keys by stem and by full filename
            const availableKeys = new Set(Object.keys(metadata));
            const stemToKey = {};
            Object.keys(metadata).forEach(k => {
                const stem = k.replace(/\.[^/.]+$/, '');
                stemToKey[stem] = k;
            });

            // Resolve CSV rows to restaurant objects (use heimlich.png as placeholder when missing)
            const restaurantsAll = csvRows.map((row, index) => {
                const imgField = (row.image_filename || '').toString().trim();
                let hasAssignedImage = false;
                let filename = null;
                if (!imgField) {
                    filename = 'heimlich.png';
                } else if (availableKeys.has(imgField)) {
                    filename = imgField;
                    hasAssignedImage = true;
                } else if (stemToKey[imgField]) {
                    filename = stemToKey[imgField];
                    hasAssignedImage = true;
                } else {
                    // try common extensions
                    const exts = ['.png', '.PNG', '.jpg', '.jpeg'];
                    for (const ex of exts) {
                        if (availableKeys.has(imgField + ex)) {
                            filename = imgField + ex;
                            hasAssignedImage = true;
                            break;
                        }
                    }
                    if (!filename) filename = 'heimlich.png';
                }

                const lat = parseFloat(row.latitude);
                const lon = parseFloat(row.longitude);
                const uid = (row.restaurant_name || `restaurant-${index}`).toString().replace(/\s+/g, '-').toLowerCase() + `-${index}`;

                return {
                    image_filename: filename,
                    restaurant_name: row.restaurant_name || '',
                    borough: row.borough || '',
                    neighborhood: row.neighborhood || '',
                    cuisine: row.cuisine || '',
                    style: row.style || '',
                    position: row.position || '',
                    uid,
                    latitude: Number.isFinite(lat) ? lat : null,
                    longitude: Number.isFinite(lon) ? lon : null,
                    hasAssignedImage
                };
            });

            const restaurants = hideEntriesWithoutImages
                ? restaurantsAll.filter(r => r.hasAssignedImage)
                : restaurantsAll;

            const data = layoutSpiral(restaurants, width, height, radius, step);
            const svg = createSVG();
            const circles = createCircles(svg, data);

            bounceControls = animateBouncing(circles, data);
            setupEventHandlers(svg, circles, data);
            initializeMap(restaurants, boroughsGeo);
            setupViewToggle();

            document.getElementById("chart").appendChild(svg.node());

            // Handle window resize for responsive scaling
            window.addEventListener('resize', () => {
                width = window.innerWidth || 928;
                height = window.innerHeight || 500;
                radius = Math.min(width, height) / 20;
                step = radius * 3.2;

                // Preserve visited state
                const visitedMap = new Map(data.map(d => [d.restaurant.restaurant_name, d.visited]));

                // Recalculate layout
                const newData = layoutSpiral(restaurants, width, height, radius, step);

                // Restore visited
                newData.forEach(d => {
                    d.visited = visitedMap.get(d.restaurant.restaurant_name) || false;
                });

                // Update data array
                data.length = 0;
                data.push(...newData);

                // Separate any overlapping circles after resize
                for (let i = 0; i < data.length; i++) {
                    for (let j = i + 1; j < data.length; j++) {
                        const d1 = data[i], d2 = data[j];
                        const dx = d1.x - d2.x, dy = d1.y - d2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 2 * radius) {
                            const n = { x: dx / dist, y: dy / dist };
                            const overlap = 2 * radius - dist;
                            d1.x += n.x * overlap / 2;
                            d1.y += n.y * overlap / 2;
                            d2.x -= n.x * overlap / 2;
                            d2.y -= n.y * overlap / 2;
                        }
                    }
                }

                // Update circles
                circles.data(data)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', radius);

                    // Update patterns
                    svg.selectAll('pattern').each(function(d, i) {
                        d3.select(this)
                            .select('image')
                            .attr('width', radius * 2)
                            .attr('height', radius * 2);
                    });

                    // Update viewBox
                    svg.attr('viewBox', [0, 0, width, height]);
                });
            });

        function layoutSpiral(restaurants, w, h, r, s) {
            let spiralCenterX = w / 2;
            let spiralCenterY = h / 2;

            const tempData = restaurants.map((restaurant, i) => {
                const rad = s * Math.sqrt(i + 0.5);
                const a = theta * i;
                return [spiralCenterX + rad * Math.cos(a), spiralCenterY + rad * Math.sin(a)];
            });

            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            tempData.forEach(([x, y]) => {
                minX = Math.min(minX, x - r);
                maxX = Math.max(maxX, x + r);
                minY = Math.min(minY, y - r);
                maxY = Math.max(maxY, y + r);
            });

            const margin = 20;
            const offsetX = (w - (maxX - minX)) / 2 - minX + margin;
            const offsetY = (h - (maxY - minY)) / 2 - minY + margin;

            const zoomFactor = 0.85;
            return restaurants.map((restaurant, i) => {
                const rad = s * Math.sqrt(i + 0.5) * zoomFactor;
                const a = theta * i;
                const x = spiralCenterX + rad * Math.cos(a) + offsetX;
                const y = spiralCenterY + rad * Math.sin(a) + offsetY;
                const vx = (Math.random() - 0.5) * 2.2;
                const vy = (Math.random() - 0.5) * 2.2;
                return { x, y, vx, vy, restaurant, visited: false };
            });
        }

        function createSVG() {
            const svg = d3.create("svg")
                .attr("viewBox", [0, 0, width, height])
                .style("cursor", "pointer");

            svg.append("g");
            const defs = svg.append("defs");

            defs.append("filter")
                .attr("id", "grayscale")
                .append("feColorMatrix")
                .attr("type", "saturate")
                .attr("values", "0");

            return svg;
        }

        function createCircles(svg, data) {
            const defs = svg.select("defs");

            data.forEach((d, i) => {
                const pattern = defs.append("pattern")
                    .attr("id", `pattern-${i}`)
                    .attr("patternUnits", "objectBoundingBox")
                    .attr("width", 1)
                    .attr("height", 1);

                pattern.append("image")
                    .attr("href", `data/${d.restaurant.image_filename}`)
                    .attr("width", radius * 2)
                    .attr("height", radius * 2)
                    .attr("preserveAspectRatio", "xMidYMid slice");
            });

            return svg.select("g").selectAll("circle")
                .data(data)
                .join("circle")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", radius)
                .attr("fill", (d, i) => `url(#pattern-${i})`)
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .attr("filter", d => d.visited ? "url(#grayscale)" : null)
                .style("cursor", "pointer");
        }

        function animateBouncing(circles, data) {
            let frameId = null;
            let paused = false;

            function step() {
                if (paused) {
                    frameId = null;
                    return;
                }

                data.forEach(d => {
                    d.x += d.vx;
                    d.y += d.vy;

                    if (d.x - radius < 0) { d.x = radius; d.vx *= -1; }
                    if (d.x + radius > width) { d.x = width - radius; d.vx *= -1; }
                    if (d.y - radius < 0) { d.y = radius; d.vy *= -1; }
                    if (d.y + radius > height) { d.y = height - radius; d.vy *= -1; }
                });

                for (let i = 0; i < data.length; i++) {
                    for (let j = i + 1; j < data.length; j++) {
                        const d1 = data[i], d2 = data[j];
                        const dx = d1.x - d2.x, dy = d1.y - d2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 2 * radius) {
                            const n = { x: dx / dist, y: dy / dist };
                            const dot = (d1.vx - d2.vx) * n.x + (d1.vy - d2.vy) * n.y;
                            d1.vx -= dot * n.x;
                            d1.vy -= dot * n.y;
                            d2.vx += dot * n.x;
                            d2.vy += dot * n.y;

                            const overlap = 2 * radius - dist;
                            d1.x += n.x * overlap / 2;
                            d1.y += n.y * overlap / 2;
                            d2.x -= n.x * overlap / 2;
                            d2.y -= n.y * overlap / 2;
                        }
                    }
                }

                circles.attr("cx", d => d.x).attr("cy", d => d.y);
                frameId = requestAnimationFrame(step);
            }

            function start() {
                if (!paused && frameId) {
                    return;
                }
                paused = false;
                if (!frameId) {
                    frameId = requestAnimationFrame(step);
                }
            }

            function stop() {
                if (paused && !frameId) {
                    return;
                }
                paused = true;
                if (frameId) {
                    cancelAnimationFrame(frameId);
                    frameId = null;
                }
            }

            start();
            return { start, stop };
        }

        function setupEventHandlers(svg, circles, data) {
            circles.on("click", (event, d) => {
                event.stopPropagation();
                if (d3.select("#corner-image").style("display") === "block") {
                    closeCard();
                } else {
                    d.visited = true;
                    circles.attr("filter", d => d.visited ? "url(#grayscale)" : null);
                    showCard(d.restaurant);
                }
            });

            svg.on("click", closeCard);
        }

        function initializeMap(restaurants, boroughsGeo) {
            const mapElement = document.getElementById('map');
            if (!mapElement) {
                return;
            }

            mapElement.innerHTML = '';

            const boroughFeatures = (boroughsGeo?.features || []).filter(feature => {
                const boro = feature?.properties?.boro_name;
                return boro === 'Manhattan' || boro === 'Brooklyn';
            });

            if (!boroughFeatures.length) {
                return;
            }

            const tooltip = d3.select('#map-tooltip');
            const tooltipTitle = tooltip.select('.tooltip-title');
            const tooltipDetails = tooltip.select('.tooltip-details');

            const svg = d3.select(mapElement)
                .append('svg')
                .attr('class', 'map-svg');

            const zoomGroup = svg.append('g').attr('class', 'map-zoom-layer');
            const boroughLayer = zoomGroup.append('g').attr('class', 'map-boroughs');
            const markerLayer = svg.append('g').attr('class', 'map-markers');

            const plottedRestaurants = restaurants.filter(r => Number.isFinite(r.latitude) && Number.isFinite(r.longitude));

            let projection = null;
            let currentTransform = d3.zoomIdentity;
            let displayNodes = [];
            const MIN_ZOOM = 1.1;
            const MAX_ZOOM = 8;
            let initialZoomApplied = false;

            const zoom = d3.zoom()
                .scaleExtent([MIN_ZOOM, MAX_ZOOM])
                .on('zoom', event => {
                    currentTransform = event.transform;
                    zoomGroup.attr('transform', currentTransform);
                    positionMarkers();
                });

            svg.call(zoom).on('dblclick.zoom', null);

            const render = () => {
                const width = mapElement.clientWidth || window.innerWidth || 800;
                const height = mapElement.clientHeight || window.innerHeight || 600;
                svg.attr('viewBox', `0 0 ${width} ${height}`);
                zoom.translateExtent([[0, 0], [width, height]]).extent([[0, 0], [width, height]]);

                projection = d3.geoMercator()
                    .fitExtent([[80, 40], [width - 80, height - 40]], {
                        type: 'FeatureCollection',
                        features: boroughFeatures
                    });

                const path = d3.geoPath(projection);

                const zoomScale = currentTransform ? currentTransform.k : 1;
                const base = 1.6;
                const min = 0.45;
                const max = 2.4;
                const exponent = 0.75;
                let strokeWidth = base / Math.pow(zoomScale, exponent);
                strokeWidth = Math.min(max, Math.max(min, strokeWidth));

                boroughLayer.selectAll('path')
                    .data(boroughFeatures)
                    .join('path')
                    .attr('d', path)
                    .attr('fill', '#f7f8fb')
                    .attr('stroke', '#111')
                    .attr('stroke-width', strokeWidth)
                    .attr('stroke-linejoin', 'round')
                    .attr('stroke-linecap', 'round')
                    .attr('vector-effect', 'non-scaling-stroke');

                plottedRestaurants.forEach(d => {
                    const projected = projection([d.longitude, d.latitude]);
                    d._mapX = projected ? projected[0] : -999;
                    d._mapY = projected ? projected[1] : -999;
                });

                positionMarkers();
                if (!initialZoomApplied) {
                    initialZoomApplied = true;
                    const center = [width / 2, height / 2];
                    const baseTransform = d3.zoomIdentity
                        .translate(center[0], center[1])
                        .scale(MIN_ZOOM)
                        .translate(-center[0], -center[1]);
                    currentTransform = baseTransform;
                    svg.call(zoom.transform, baseTransform);
                }
                zoomGroup.attr('transform', currentTransform);
            };

            function updateTooltip(event, d) {
                if (d.type === 'cluster') {
                    hideTooltip();
                    hideMapCompare();
                    closeLegend();
                    return;
                }
                tooltipTitle.text(d.restaurant_name || 'Unknown');
                const metaParts = [d.cuisine, d.style, d.position].map(v => (v || '').trim()).filter(Boolean);
                tooltipDetails.text(metaParts.join(' \u00b7 ') || '');
                tooltip
                    .style('display', 'block')
                    .style('left', `${event.clientX + 16}px`)
                    .style('top', `${event.clientY + 16}px`);
            }

            function hideTooltip() {
                tooltip.style('display', 'none');
            }

            function attachInteractions(selection) {
                selection
                    .on('mouseenter', (event, d) => {
                        event.stopPropagation();
                        if (d.type === 'point') {
                            d3.select(event.currentTarget).select('circle').style('fill', '#d11a2a');
                        }
                        updateTooltip(event, d);
                        if (d.type === 'point' && mapCompareEl && currentView === 'map') {
                            const posterSrc = d.image_filename ? `data/${d.image_filename}` : '';
                            mapCompareRestaurantImg?.setAttribute('src', posterSrc);
                            mapCompareRestaurantImg?.setAttribute('alt', d.restaurant_name || 'Restaurant poster');
                            if (mapCompareRestaurantCaption) {
                                mapCompareRestaurantCaption.textContent = d.restaurant_name || '';
                            }
                            mapCompareEl.classList.add('visible');
                            mapCompareEl.setAttribute('aria-hidden', 'false');
                        }
                    })
                    .on('mousemove', (event, d) => {
                        if (tooltip.style('display') === 'block') {
                            tooltip
                                .style('left', `${event.clientX + 16}px`)
                                .style('top', `${event.clientY + 16}px`);
                        }
                    })
                    .on('mouseleave', (event) => {
                        d3.select(event.currentTarget).select('circle').style('fill', null);
                        hideTooltip();
                        hideMapCompare();
                        if (!legendOpen) {
                            closeLegend();
                        }
                    })
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        if (d.type === 'cluster') {
                            svg.transition().duration(350).call(
                                zoom.scaleBy,
                                1.6,
                                [d.x, d.y]
                            );
                        }
                    });
            }

            function buildClusters(points, thresholdPx) {
                const clusters = [];
                const cellSize = thresholdPx;
                const grid = new Map();

                const keyFor = (x, y) => `${Math.floor(x / cellSize)}-${Math.floor(y / cellSize)}`;

                points.forEach(pt => {
                    const key = keyFor(pt._screenX, pt._screenY);
                    let cluster = grid.get(key);
                    if (!cluster) {
                        cluster = {
                            id: `cluster-${key}-${clusters.length}`,
                            type: 'cluster',
                            x: pt._screenX,
                            y: pt._screenY,
                            count: 1
                        };
                        grid.set(key, cluster);
                        clusters.push(cluster);
                    } else {
                        cluster.count += 1;
                        cluster.x += (pt._screenX - cluster.x) / cluster.count;
                        cluster.y += (pt._screenY - cluster.y) / cluster.count;
                    }
                });

                return clusters;
            }

            function applyDuplicateOffsets(points) {
                const groups = new Map();
                points.forEach(pt => {
                    const key = `${pt._mapX.toFixed(3)}-${pt._mapY.toFixed(3)}`;
                    if (!groups.has(key)) groups.set(key, []);
                    groups.get(key).push(pt);
                });

                groups.forEach(list => {
                    if (list.length === 1) {
                        list[0]._screenX = currentTransform.applyX(list[0]._mapX);
                        list[0]._screenY = currentTransform.applyY(list[0]._mapY);
                        return;
                    }
                    const radius = 10;
                    list.forEach((pt, idx) => {
                        const angle = (idx / list.length) * Math.PI * 2;
                        const x = pt._mapX + Math.cos(angle) * radius;
                        const y = pt._mapY + Math.sin(angle) * radius;
                        pt._screenX = currentTransform.applyX(x);
                        pt._screenY = currentTransform.applyY(y);
                    });
                });
            }

            function positionMarkers() {
                if (!plottedRestaurants.length) return;

                const k = currentTransform.k || 1;
                const showClusters = k < 2.3;
                if (mapInfoEl) {
                    const shouldShowInfo = currentView === 'map' && showClusters;
                    mapInfoEl.classList.toggle('visible', shouldShowInfo);
                    mapInfoEl.setAttribute('aria-hidden', shouldShowInfo ? 'false' : 'true');
                }
                if (mapCompareEl && showClusters) {
                    hideMapCompare();
                }

                if (showClusters) {
                    plottedRestaurants.forEach(pt => {
                        pt._screenX = currentTransform.applyX(pt._mapX);
                        pt._screenY = currentTransform.applyY(pt._mapY);
                    });
                    displayNodes = buildClusters(plottedRestaurants, 40);
                } else {
                    applyDuplicateOffsets(plottedRestaurants);
                    displayNodes = plottedRestaurants.map(pt => ({
                        type: 'point',
                        id: pt.uid || pt.restaurant_name,
                        x: pt._screenX,
                        y: pt._screenY,
                        image_filename: pt.image_filename,
                        restaurant_name: pt.restaurant_name,
                        neighborhood: pt.neighborhood,
                        borough: pt.borough,
                        position: pt.position,
                        cuisine: pt.cuisine,
                        style: pt.style
                    }));
                }

                const markers = markerLayer.selectAll('g.map-marker')
                    .data(displayNodes, d => d.id)
                    .join(enter => {
                        const g = enter.append('g')
                            .attr('class', 'map-marker');
                        g.append('circle');
                        return g;
                    });

                markers
                    .classed('is-cluster', d => d.type === 'cluster')
                    .classed('is-point', d => d.type === 'point');

                markers.select('circle')
                    .attr('r', d => d.type === 'cluster' ? Math.min(16, 8 + Math.log2(d.count) * 3) : 6)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                attachInteractions(markers);
            }

            render();
            window.addEventListener('resize', () => {
                hideTooltip();
                render();
            });
            mapState.render = () => {
                hideTooltip();
                render();
            };

            d3.select(mapElement).on('click', () => {
                hideTooltip();
                closeCard();
            });

            // Legend interactions
            if (legendHotspot && legendButton && legendPanel) {
                const handleMouseMove = (e) => {
                    const dx = window.innerWidth - e.clientX;
                    const dy = window.innerHeight - e.clientY;
                    const nearCorner = dx <= LEGEND_HOVER_MARGIN && dy <= LEGEND_HOVER_MARGIN;
                    if (nearCorner || legendOpen) {
                        legendButton.classList.add('show');
                    } else if (!legendOpen) {
                        legendButton.classList.remove('show');
                    }
                };

                const toggleLegend = () => {
                    legendOpen = !legendOpen;
                    legendPanel.classList.toggle('visible', legendOpen);
                    legendPanel.setAttribute('aria-hidden', legendOpen ? 'false' : 'true');
                    legendButton.classList.add('show'); // keep button visible; hide only on hover out
                };

                legendButton.addEventListener('click', toggleLegend);
                legendButton.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        toggleLegend();
                    }
                });

                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('click', (e) => {
                    if (!legendOpen) return;
                    const clickedLegend = legendPanel.contains(e.target) || legendButton.contains(e.target);
                    if (!clickedLegend) {
                        closeLegend();
                    }
                });
            }
        }

        function setupViewToggle() {
            const buttons = document.querySelectorAll('#view-toggle button');
            const chart = document.getElementById('chart');
            const mapEl = document.getElementById('map');

            if (!chart || !mapEl || !buttons.length) {
                return;
            }

            function setActive(view) {
                buttons.forEach(btn => {
                    const isActive = btn.dataset.view === view;
                    btn.classList.toggle('active', isActive);
                    btn.setAttribute('aria-pressed', isActive);
                });
                if (mapEl) {
                    mapEl.setAttribute('aria-hidden', view === 'bubbles');
                }
                const toggle = document.getElementById('view-toggle');
                if (toggle) toggle.setAttribute('data-active', view);
            }

            function switchView(view) {
                if (view === currentView) {
                    return;
                }
                currentView = view;

                if (view === 'map') {
                    if (mapInfoEl) {
                        mapInfoEl.style.transition = 'none'; // prevent initial fade-in
                    }
                    chart.style.display = 'none';
                    mapEl.style.display = 'block';
                    if (bounceControls) {
                        bounceControls.stop();
                    }
                    closeCard();
                    requestAnimationFrame(() => {
                        if (mapState.render) {
                            mapState.render();
                        }
                        requestAnimationFrame(() => {
                            if (mapInfoEl) {
                                mapInfoEl.style.transition = '';
                            }
                        });
                    });
                } else {
                    mapEl.style.display = 'none';
                    chart.style.display = 'block';
                    if (bounceControls) {
                        bounceControls.start();
                    }
                    hideGlobalMapTooltip();
                    if (mapInfoEl) {
                        mapInfoEl.classList.remove('visible');
                        mapInfoEl.setAttribute('aria-hidden', 'true');
                    }
                    hideMapCompare();
                    closeLegend();
                }

                setActive(view);
            }

            buttons.forEach(btn => {
                btn.addEventListener('click', () => switchView(btn.dataset.view));
            });

            setActive(currentView);
        }

        function applyCardAccent(color) {
            const accent = color || '#111';
            d3.select("#corner-title").style("color", accent);
            d3.selectAll("#corner-info b").style("color", accent);
        }

        function getVibrantColor(imageFilename) {
            const safeFilename = imageFilename || 'heimlich.png';
            if (colorCache.has(safeFilename)) {
                return Promise.resolve(colorCache.get(safeFilename));
            }
            return new Promise(resolve => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                const finalize = color => {
                    const fallback = color || '#111';
                    colorCache.set(safeFilename, fallback);
                    resolve(fallback);
                };
                img.onload = () => {
                    try {
                        const size = 80;
                        const canvas = document.createElement('canvas');
                        canvas.width = size;
                        canvas.height = size;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, size, size);
                        const { data } = ctx.getImageData(0, 0, size, size);
                        let bestSat = -1;
                        let bestColor = [17, 17, 17];
                        let avgR = 0, avgG = 0, avgB = 0, count = 0;
                        for (let i = 0; i < data.length; i += 4) {
                            const alpha = data[i + 3];
                            if (alpha < 150) continue;
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            avgR += r;
                            avgG += g;
                            avgB += b;
                            count++;
                            const rn = r / 255;
                            const gn = g / 255;
                            const bn = b / 255;
                            const maxN = Math.max(rn, gn, bn);
                            const minN = Math.min(rn, gn, bn);
                            const delta = maxN - minN;
                            if (delta < 0.08) continue;
                            const lightness = (maxN + minN) / 2;
                            if (lightness > 0.85 || lightness < 0.15) continue;
                            const denom = 1 - Math.abs(2 * lightness - 1);
                            const saturation = denom ? delta / denom : 0;
                            if (saturation > bestSat) {
                                bestSat = saturation;
                                bestColor = [r, g, b];
                            }
                        }
                        let color = '#111';
                        if (bestSat > 0) {
                            color = `rgb(${bestColor[0]}, ${bestColor[1]}, ${bestColor[2]})`;
                        } else if (count) {
                            color = `rgb(${Math.round(avgR / count)}, ${Math.round(avgG / count)}, ${Math.round(avgB / count)})`;
                        }
                        finalize(color);
                    } catch (err) {
                        finalize('#111');
                    }
                };
                img.onerror = () => finalize('#111');
                img.src = `data/${safeFilename}`;
            });
        }

        function showCard(restaurant) {
            d3.select("#corner-img").attr("src", `data/${restaurant.image_filename}`);
            d3.select("#corner-image").style("display", "block");

            d3.select("#corner-title").text(restaurant.restaurant_name);
            d3.select("#corner-borough").text(restaurant.borough || "N/A");
            d3.select("#corner-neighborhood").text(restaurant.neighborhood || "N/A");
            d3.select("#corner-cuisine").text(restaurant.cuisine);
            d3.select("#corner-style").text(restaurant.style);
            d3.select("#corner-position").text(restaurant.position);
            d3.select("#corner-info").style("display", "block");
            applyCardAccent('#111');
            const thisAccentToken = ++cardAccentToken;
            getVibrantColor(restaurant.image_filename).then(color => {
                if (thisAccentToken !== cardAccentToken) return;
                applyCardAccent(color);
            });

            d3.select("#chart").classed("dimmed", true);
        }

        function closeCard() {
            d3.select("#corner-image").style("display", "none");
            d3.select("#corner-info").style("display", "none");
            d3.select("#chart").classed("dimmed", false);
        }
    </script>
</body>
</html>
